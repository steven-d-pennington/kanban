/**
 * PR Creator
 *
 * Creates GitHub pull requests with code changes.
 * Note: Requires GITHUB_TOKEN environment variable.
 */

import type { PRInput, PRResult } from './types';

/**
 * Creates pull requests for code changes.
 */
export class PRCreator {
  private owner: string;
  private repo: string;
  private token: string;

  constructor() {
    this.token = process.env.GITHUB_TOKEN || '';
    this.owner = process.env.GITHUB_OWNER || '';
    this.repo = process.env.GITHUB_REPO || '';
  }

  /**
   * Check if GitHub integration is configured.
   */
  isConfigured(): boolean {
    return !!(this.token && this.owner && this.repo);
  }

  /**
   * Create a pull request with the given changes.
   */
  async create(input: PRInput): Promise<PRResult> {
    if (!this.isConfigured()) {
      // Return a mock result when GitHub is not configured
      return this.createMockResult(input);
    }

    const branchName = this.generateBranchName(input.item);

    try {
      // Get base branch SHA
      const baseBranch = 'main';
      const baseRef = await this.getRef(baseBranch);

      // Create new branch
      await this.createBranch(branchName, baseRef);

      // Commit changes
      for (const change of input.changes.files) {
        if (change.action === 'delete') {
          await this.deleteFile(branchName, change.path);
        } else if (change.content) {
          await this.createOrUpdateFile(branchName, change.path, change.content);
        }
      }

      // Create PR
      const pr = await this.createPullRequest({
        title: `${input.item.type}: ${input.item.title}`,
        head: branchName,
        base: baseBranch,
        body: this.generatePRBody(input),
      });

      return {
        url: pr.html_url,
        number: pr.number,
        branch: branchName,
      };
    } catch (error) {
      console.error('Failed to create PR:', error);
      throw error;
    }
  }

  /**
   * Generate branch name from work item.
   */
  private generateBranchName(item: { type: string; title: string; id: string }): string {
    const sanitizedTitle = item.title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '')
      .slice(0, 50);

    return `${item.type}/${sanitizedTitle}-${item.id.slice(0, 8)}`;
  }

  /**
   * Generate PR body markdown.
   */
  private generatePRBody(input: PRInput): string {
    return `## Summary
${input.plan.summary}

## Changes
${input.changes.summary}

## Related Work Item
- **Type:** ${input.item.type}
- **Title:** ${input.item.title}
- **ID:** ${input.item.id}

## Implementation Plan
${input.plan.steps.map((s, i) => `${i + 1}. ${s.description}`).join('\n')}

## Tests
${input.plan.tests.map(t => `- ${t.file}: ${t.scenarios.length} scenarios`).join('\n') || 'No tests added'}

## Risks
${input.plan.risks.map(r => `- ${r}`).join('\n') || 'None identified'}

---
*This PR was automatically generated by Developer Agent*`;
  }

  /**
   * Create a mock result when GitHub is not configured.
   */
  private createMockResult(input: PRInput): PRResult {
    const branchName = this.generateBranchName(input.item);
    console.log(`[Mock] Would create PR for branch: ${branchName}`);
    console.log(`[Mock] Changes: ${input.changes.summary}`);

    return {
      url: `https://github.com/${this.owner || 'owner'}/${this.repo || 'repo'}/pull/0`,
      number: 0,
      branch: branchName,
    };
  }

  // GitHub API methods (simplified - would use Octokit in production)

  private async getRef(branch: string): Promise<string> {
    const response = await fetch(
      `https://api.github.com/repos/${this.owner}/${this.repo}/git/refs/heads/${branch}`,
      {
        headers: {
          Authorization: `token ${this.token}`,
          Accept: 'application/vnd.github.v3+json',
        },
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to get ref: ${response.statusText}`);
    }

    const data = await response.json() as { object: { sha: string } };
    return data.object.sha;
  }

  private async createBranch(branchName: string, sha: string): Promise<void> {
    const response = await fetch(
      `https://api.github.com/repos/${this.owner}/${this.repo}/git/refs`,
      {
        method: 'POST',
        headers: {
          Authorization: `token ${this.token}`,
          Accept: 'application/vnd.github.v3+json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          ref: `refs/heads/${branchName}`,
          sha,
        }),
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to create branch: ${response.statusText}`);
    }
  }

  private async createOrUpdateFile(branch: string, path: string, content: string): Promise<void> {
    // Get current file SHA if it exists
    let sha: string | undefined;
    try {
      const getResponse = await fetch(
        `https://api.github.com/repos/${this.owner}/${this.repo}/contents/${path}?ref=${branch}`,
        {
          headers: {
            Authorization: `token ${this.token}`,
            Accept: 'application/vnd.github.v3+json',
          },
        }
      );
      if (getResponse.ok) {
        const data = await getResponse.json() as { sha: string };
        sha = data.sha;
      }
    } catch {
      // File doesn't exist, which is fine for create
    }

    const response = await fetch(
      `https://api.github.com/repos/${this.owner}/${this.repo}/contents/${path}`,
      {
        method: 'PUT',
        headers: {
          Authorization: `token ${this.token}`,
          Accept: 'application/vnd.github.v3+json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          message: `${sha ? 'Update' : 'Create'} ${path}`,
          content: Buffer.from(content).toString('base64'),
          branch,
          ...(sha ? { sha } : {}),
        }),
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to ${sha ? 'update' : 'create'} file: ${response.statusText}`);
    }
  }

  private async deleteFile(branch: string, path: string): Promise<void> {
    // Get current file SHA
    const getResponse = await fetch(
      `https://api.github.com/repos/${this.owner}/${this.repo}/contents/${path}?ref=${branch}`,
      {
        headers: {
          Authorization: `token ${this.token}`,
          Accept: 'application/vnd.github.v3+json',
        },
      }
    );

    if (!getResponse.ok) {
      console.warn(`File ${path} not found, skipping delete`);
      return;
    }

    const data = await getResponse.json() as { sha: string };

    const response = await fetch(
      `https://api.github.com/repos/${this.owner}/${this.repo}/contents/${path}`,
      {
        method: 'DELETE',
        headers: {
          Authorization: `token ${this.token}`,
          Accept: 'application/vnd.github.v3+json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          message: `Delete ${path}`,
          sha: data.sha,
          branch,
        }),
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to delete file: ${response.statusText}`);
    }
  }

  private async createPullRequest(options: {
    title: string;
    head: string;
    base: string;
    body: string;
  }): Promise<{ html_url: string; number: number }> {
    const response = await fetch(
      `https://api.github.com/repos/${this.owner}/${this.repo}/pulls`,
      {
        method: 'POST',
        headers: {
          Authorization: `token ${this.token}`,
          Accept: 'application/vnd.github.v3+json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(options),
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to create PR: ${response.statusText}`);
    }

    return response.json() as Promise<{ html_url: string; number: number }>;
  }
}
